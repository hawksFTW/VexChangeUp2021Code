#include "vex.h"
#include "robot-config.h"
#include <iostream>

using namespace vex;
competition Competition;

void pre_auton(void) {
// Initializing Robot Configuration.
vexcodeInit();
// All activities that occur before the competition starts
// Example: clearing encoders, setting servo positions, ...
}

double kP = -0.03; //-0.05
double kI = 0;
double kD = 0; //-0.02
double turnkP = -0.2; //-0.2
double turnkI = 0;
double turnkD = 0;
int maxTurnIntegral = 300; // These cap the integrals
int maxIntegral = 300;
int integralBound = 3; //If error is outside the bounds, then apply the integral. This is a buffer with +-integralBound degrees

//Autonomous Settings
int desiredValue = 0;
int desiredTurnValue = 0;

int error; //SensorValue - DesiredValue : Position
int prevError = 0; //Position 20 miliseconds ago
int derivative; // error - prevError : Speed
int totalError = 0; //totalError = totalError + error

int turnError; //SensorValue - DesiredValue : Position
int turnPrevError = 0; //Position 20 miliseconds ago
int turnDerivative; // error - prevError : Speed
int turnTotalError = 0; //totalError = totalError + error

bool resetDriveSensors = false;

//Variables modified for use
bool enableDrivePID = true;

//Pasted from a C++ resource
double signnum_c(double x) {
  if (x > 0.0) return 1.0;
  if (x < 0.0) return -1.0;
  return x;
}

void drivePID(double desiredValue){
  int leftfrontMotorPosition = leftFront.position(degrees);
  int rightfrontMotorPosition = rightFront.position(degrees);
  int rightbackMotorPosition = rightBack.position(degrees);
  int leftbackMotorPosition = leftBack.position(degrees);
  int averagePosition = (leftfrontMotorPosition + rightfrontMotorPosition + leftbackMotorPosition + rightbackMotorPosition)/4;
  error = averagePosition - desiredValue;
  while(error > 30){

    if (resetDriveSensors) {
      resetDriveSensors = false;
      leftFront.setPosition(0,degrees);
      rightFront.setPosition(0,degrees);
      leftBack.setPosition(0,degrees);
      rightBack.setPosition(0,degrees);
    }

    //Get the position of four motors
    int leftfrontMotorPosition = leftFront.position(degrees);
    int rightfrontMotorPosition = rightFront.position(degrees);
    int rightbackMotorPosition = rightBack.position(degrees);
    int leftbackMotorPosition = leftBack.position(degrees);
    ///////////////////////////////////////////
    //Lateral movement PID
    /////////////////////////////////////////////////////////////////////
    //Get average of the four motors
    int averagePosition = (leftfrontMotorPosition + rightfrontMotorPosition + leftbackMotorPosition + rightbackMotorPosition)/4;
    
    //Potential
    error = averagePosition - desiredValue;

    //Derivative
    derivative = error - prevError;

    //Integral
    if(abs(error) < integralBound){
    totalError+=error; 
    }  else {
    totalError = 0; 
    }
    //totalError += error;
    //This would cap the integral
    totalError = abs(totalError) > maxIntegral ? signnum_c(totalError) * maxIntegral : totalError;

    double lateralMotorPower = error * kP + derivative * kD;
    /////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////
    //Turning movement PID
    /////////////////////////////////////////////////////////////////////
    //Get average of the two motors
    int turnDifference = leftfrontMotorPosition && leftbackMotorPosition - rightbackMotorPosition && rightfrontMotorPosition;

    //Potential
    turnError = turnDifference - desiredTurnValue;

    //Derivative
    turnDerivative = turnError - turnPrevError;

    //Integral
    if(abs(error) < integralBound){
    turnTotalError+=turnError; 
    }  else {
    turnTotalError = 0; 
    }
    //turnTotalError += turnError;

    //This would cap the integral
    turnTotalError = abs(turnTotalError) > maxIntegral ? signnum_c(turnTotalError) * maxIntegral : turnTotalError;

     double turnMotorPower = turnError * turnkP + turnDerivative * turnkD + turnTotalError * turnkI;
    /////////////////////////////////////////////////////////////////////

    leftFront.spin(forward, lateralMotorPower + turnMotorPower , voltageUnits::volt);
    leftBack.spin(forward, lateralMotorPower + turnMotorPower, voltageUnits::volt); //reverse
    rightFront.spin(forward, lateralMotorPower - turnMotorPower , voltageUnits::volt);
    rightBack.spin(forward, lateralMotorPower - turnMotorPower , voltageUnits::volt); //reverse

    prevError = error;
    turnPrevError = turnError;
    //vex::task::sleep(20);
  }

  leftFront.stop();
  rightFront.stop();
  leftBack.stop();
  rightBack.stop();

}

double reading = 0;
int updateTurn()
{
  while(true)
  {
    reading = inertialSensor.value();
    std::cout<<reading<<std::endl;
  }
  return 1;
}

void turnDegrees(double deg)
{
  turnError = deg - desiredTurnValue;
  while(turnError > 2)
  {
    turnError = deg - desiredTurnValue;
    double turnMotorPower = turnError * turnkP;    
    leftFront.spin(forward, turnMotorPower, voltageUnits::volt);
    leftBack.spin(forward, turnMotorPower, voltageUnits::volt); //reverse
    rightFront.spin(forward, turnMotorPower, voltageUnits::volt);
    rightBack.spin(forward, turnMotorPower, voltageUnits::volt);
  }  
  leftFront.stop();
  rightFront.stop();
  leftBack.stop();
  rightBack.stop();
}

void rightTurn(int t) 
{
  //t = 350 is a 90 degree turn
  leftFront.startRotateFor(directionType::fwd, -t, rotationUnits::deg, 30, velocityUnits::rpm);
  rightFront.startRotateFor(directionType::fwd, t, rotationUnits::deg, 30, velocityUnits::rpm);
  leftBack.startRotateFor(directionType::fwd, -t, rotationUnits::deg, 30, velocityUnits::rpm);
  rightBack.rotateFor(directionType::fwd, t, rotationUnits::deg, 30, velocityUnits::rpm);
}

void leftTurn(int x) 
{
  leftFront.startRotateFor(directionType::fwd, x, rotationUnits::deg, 30, velocityUnits::rpm);
  rightFront.startRotateFor(directionType::fwd, -x, rotationUnits::deg, 30, velocityUnits::rpm);
  leftBack.startRotateFor(directionType::fwd, x, rotationUnits::deg, 30, velocityUnits::rpm);
  rightBack.rotateFor(directionType::fwd, -x, rotationUnits::deg, 30, velocityUnits::rpm);
}


void moveForward(int d)
{
  //d = 650 is 24 inches
  leftFront.startRotateFor(directionType::fwd, -d, rotationUnits::deg, 40, velocityUnits::rpm);
  rightFront.startRotateFor(directionType::fwd, -d, rotationUnits::deg, 40, velocityUnits::rpm);
  leftBack.startRotateFor(directionType::fwd, -d, rotationUnits::deg, 40, velocityUnits::rpm);
  rightBack.rotateFor(directionType::fwd, -d, rotationUnits::deg, 40, velocityUnits::rpm);
}

void speedForward(int s)
{
  //d = 650 is 24 inches
  leftFront.startRotateFor(directionType::fwd, -s, rotationUnits::deg, 80, velocityUnits::rpm);
  rightFront.startRotateFor(directionType::fwd, -s, rotationUnits::deg, 80, velocityUnits::rpm);
  leftBack.startRotateFor(directionType::fwd, -s, rotationUnits::deg, 80, velocityUnits::rpm);
  rightBack.rotateFor(directionType::fwd, -s, rotationUnits::deg, 80, velocityUnits::rpm);
}

void forwardIntake(int x)
{
  intakeRight.spin(directionType::fwd, 100, percentUnits::pct);
  intakeLeft.spin(directionType::rev, 100, percentUnits::pct);
  moveForward(x);
  intakeRight.stop();
  intakeLeft.stop();
}

void spinOutakes(double o)
{
  outtakeUp.spin(directionType::fwd, 90, percentUnits::pct);
  wait(o, sec);
  outtakeUp.stop();
}

void spinIntakes(int t)
{
  intakeRight.spin(directionType::fwd, 100, percentUnits::pct);
  intakeLeft.spin(directionType::rev, 100, percentUnits::pct);
  wait(t, sec);
  intakeRight.stop();
  intakeLeft.stop();
}

void backSpinIntakes(int t)
{
  intakeRight.spin(directionType::rev, 100, percentUnits::pct);
  intakeLeft.spin(directionType::fwd, 100, percentUnits::pct);
  wait(t, sec);
  intakeRight.stop();
  intakeLeft.stop();
}

void backSpinOutakes(double o)
{
  outtakeUp.spin(directionType::rev, 90, percentUnits::pct);
  wait(o, sec);
  outtakeUp.stop();
}

void intOut(double i)
{
  intakeRight.spin(directionType::fwd, 100, percentUnits::pct);
  intakeLeft.spin(directionType::rev, 100, percentUnits::pct);
  spinOutakes(i);
  intakeRight.stop();
  intakeLeft.stop();
}

void moveBackward(int b)
{
  leftFront.startRotateFor(directionType::fwd, b, rotationUnits::deg, 30, velocityUnits::rpm);
  rightFront.startRotateFor(directionType::fwd, b, rotationUnits::deg, 30, velocityUnits::rpm);
  leftBack.startRotateFor(directionType::fwd, b, rotationUnits::deg, 30, velocityUnits::rpm);
  rightBack.rotateFor(directionType::fwd, b, rotationUnits::deg, 30, velocityUnits::rpm);
}

void strafe(int s)
{
  leftFront.startRotateFor(directionType::rev, s, rotationUnits::deg, 30, velocityUnits::rpm);
  rightFront.startRotateFor(directionType::fwd, s, rotationUnits::deg, 30, velocityUnits::rpm);
  leftBack.startRotateFor(directionType::fwd, s, rotationUnits::deg, 30, velocityUnits::rpm);
  rightBack.rotateFor(directionType::rev, s, rotationUnits::deg, 30, velocityUnits::rpm);
}  

void backIntake(int j)
{
  intakeRight.spin(directionType::rev, 100, percentUnits::pct);
  intakeLeft.spin(directionType::fwd, 100, percentUnits::pct);
  moveBackward(j);
  intakeRight.stop();
  intakeLeft.stop();
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

void autonomous(void) {

  //38.21 ticks per inch
  //1000 ticks to get to center field
  //resetDriveSensors = true;
  // Skills auton
  // drivePID(-955);
  // moveBackward(200);
  // wait(0.5, sec);
  // moveForward(280);
  // moveBackward(200);
  // moveForward(250);
  // wait(1, sec);
  // moveBackward(100);
  // strafe(-200);
  // moveForward(100);
  // //rightTurn(150);
  // wait(0.5, sec);
  // spinOutakes(3);
  // wait(1, sec);
  // moveBackward(300);

  spinOutakes(0.2);
  forwardIntake(425);
  //leftTurn(280);
  //moveForward(350);
  leftTurn(425);
  moveForward(525);
  wait(0.5, sec);
  spinOutakes(0.5);
  //intOut(1);
  forwardIntake(-100);
  //spinIntakes(2);
  //moveBackward(100);
  //backIntake(2);
  moveForward(125);
  //spinIntakes(1);
  forwardIntake(-200);
  //spinIntakes(2);
  //backIntake(2);
  moveBackward(100);
  leftTurn(280);
  backSpinOutakes(0.5);
  backSpinIntakes(2);
  rightTurn(280);
  moveForward(325);
  spinOutakes(0.75);
  moveBackward(200);
  rightTurn(165);
  strafe(150);
  moveForward(275);
  forwardIntake(-300);
  //wait(1, sec);
  // spinIntakes(3);
  // spinOutakes(2);
  //spinOutakes(2);
  //intOut(3);
  //wait(1, sec);
  //moveBackward(300);
  wait(0.5, sec);
  rightTurn(280);
  moveBackward(450);
  moveForward(700);
  strafe(575);
  //leftTurn(100);
  //rightTurn(280);
  speedForward(250);
  moveBackward(100);
  speedForward(200);
  moveBackward(100);
  //leftTurn(75);
  //strafe(50);
  speedForward(150);
  wait(1, sec);
  intOut(1);
  //spinOutakes(1);
  wait(1, sec);
}


void usercontrol(void) {
  
  while(1)
  {


    //Code that works:
    // rightFront.spin(forward, (-Controller1.Axis2.value() + Controller1.Axis1.value() + Controller1.Axis4.value()) * 0.2, percent);
    // leftBack.spin(forward, (-Controller1.Axis2.value() + Controller1.Axis1.value() - Controller1.Axis4.value()) * 0.2, percent);
    // leftFront.spin(forward, (-Controller1.Axis2.value() - Controller1.Axis1.value() - Controller1.Axis4.value()) * 0.2, percent);
    // rightBack.spin(forward, (-Controller1.Axis2.value() - Controller1.Axis1.value() + Controller1.Axis4.value()) * 0.2, percent);


    //Code:
    rightFront.spin(forward, (-Controller1.Axis2.value() + Controller1.Axis1.value()) * 0.6 + (Controller1.Axis4.value()) * 0.25, percent);
    leftBack.spin(forward, (-Controller1.Axis2.value() + Controller1.Axis1.value()) * 0.6 - (Controller1.Axis4.value()) * 0.25, percent);
    leftFront.spin(forward, (-Controller1.Axis2.value() - Controller1.Axis1.value()) * 0.6 - (Controller1.Axis4.value()) * 0.25, percent);
    rightBack.spin(forward, (-Controller1.Axis2.value() - Controller1.Axis1.value()) * 0.6 + (Controller1.Axis4.value()) * 0.25, percent);



    if(Controller1.ButtonR1.pressing())
    {
      intakeLeft.spin(vex::directionType::rev, 100, vex::velocityUnits::pct);
      intakeRight.spin(vex::directionType::fwd, 100, vex::velocityUnits::pct);
    }
    else if(Controller1.ButtonR2.pressing())
    {
      intakeLeft.spin(vex::directionType::fwd, 100, vex::velocityUnits::pct);
      intakeRight.spin(vex::directionType::rev, 100, vex::velocityUnits::pct);
    }
    else
    {
      intakeLeft.stop();
      intakeRight.stop();
    }

    if(Controller1.ButtonL1.pressing())
    {
      outtakeUp.spin(vex::directionType::fwd, 100, vex::velocityUnits::pct);
      //outtakeDown.spin(vex::directionType::fwd, 100, vex::velocityUnits::pct);    
    }
    else if(Controller1.ButtonL2.pressing())
    {
      outtakeUp.spin(vex::directionType::rev, 100, vex::velocityUnits::pct);
      //outtakeDown.spin(vex::directionType::fwd, 100, vex::velocityUnits::pct);    
    }
    else
    {
      outtakeUp.stop();
    }
  
  }

} 


int main() 
{
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);
}
